数据库

#### SQL 语法

```
// 创建数据表
CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

// 删除数据表
DROP TABLE table_name ;

// 插入数据
INSERT INTO table_name ( field1, field2,...fieldN )
                       VALUES
                       ( value1, value2,...valueN );
                       
// 更新数据
UPDATE table_name SET field1=new-value1, field2=new-value2
[WHERE Clause]

// 删除数据
DELETE FROM table_name [WHERE Clause]
```



**LIKE 关键字**： LIKE 关键字用来搜索 「含有某个字段」，它使用百分号 **%**字符来表示任意字符，类似于UNIX或正则表达式中的星号 *

```SELECT * from runoob_tbl  WHERE runoob_author LIKE '%COM';```

**UNION 关键字**：连接两个以上的 SELECT 语句的结果组合到一个结果集合中。连接的两个 SELECT 语句必须具有相同数目的表达式，并且数据类型相同。

```
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions]
UNION [ALL | DISTINCT]
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions];
```

- ALL: 返回所有结果集，包含重复数据
- DISTINCT / UNION : 删除结果集中重复的数据

JOIN 连接：

JOIN 一共分为以下几种类型：

- 内连接 (inner join) ：只返回两张表匹配的记录

- 左连接 (left join)：获取左表所有记录，即使右表没有对应匹配的记录。

- 右连接 (right join)：用于获取右表所有记录，即使左表没有对应匹配的记录。

- 全连接 (full join)：返回匹配的记录，以及表 A 和表 B 各自的多余记录

- 交叉连接 (cross join)：表 A 和表 B 不存在关联字段，这时表 A（共有 n 条记录）与表 B （共有 m 条记录）连接后，会产生一张包含 n x m 条记录的新表

  ![img](https://www.wangbase.com/blogimg/asset/201901/bg2019011506.jpg)

  ![img](https://www.wangbase.com/blogimg/asset/201901/bg2019011507.png)

检查 Null 值：用 ``` IS NULL``` 或者``` IS NOT NULL```

```SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;```

#### 数据库的关系模型

主键：能够通过某个字段唯一区分出不同的记录，这个字段成为主键。

联合主键：即两个或更多的字段都设置为主键。对于联合主键，允许一列有重复，只要不是所有主键列都重复即可。

外键：第二张表包含一个在第一张表是主键的字段，用来把数据与另一张表关联起来。

#### 范式

- **第一范式**：每一个属性都不可再分。

  假如数据库包含一个地址字段，地址可以再细分成xx市xx区xx路。

- **第二范式**：在满足第一范式的情况下，表中的属性必须完全依赖于全部主键，而不是部分主键。

  e.g. 假设 Employee 职员表，包括departmentDescription，department。但departmentDescription 是由主键 DepartmentName 所决定，但却不是由主键EmployeeID决定

- **第三范式**：在满足第二范式的情况下，非主键外的所有字段必须互不依赖。

  e.g. 设 Employee 职员表，包括 job 和  jobDescription。但是 jobDescription 依赖于 job。

- **第四范式**：在满足第二范式的情况下，消除表中的多值依赖

  可以减少维护数据一致性的工作。e.g. skills 数据段存在多个值，比如Java, python。那么需要将多值属性放入一个新表。

#### 事务

##### ACID

事务是数据库操作的一个程序执行单元。它满足ACID性质

1. 原子性（Atomicity）

   事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

2. 一致性 （Consistency）

   事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

   数据库通过日志来实现一致性。数据库将旧值写在硬盘的一个文件上，也就是日志里。如果事务没能成功执行，那么数据库从文件中恢复旧值。

3. 隔离性（Isolation）

   一个事务所做的修改在最终提交以前，对其它事务是不可见的。

4. 持久性（Durability）

   一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

```
BEGIN;  //开始事务
insert into runoob_transaction_test value(5);
insert into runoob_transaction_test value(6);
ROLLBACK; 事务回滚
COMMIT; // 提交事务
```

##### 可串行化

事务的调度可以是串行的，也可以是并行的。当并发执行两个事务时，操作系统会选一个事务执行一小段时间，然后切换上下文执行另一个事务。不是所有的并行调度计划都可以保证数据的一致性。只有在并发执行中，执行的效果与没有并发执行效果一致，才可以保证数据的一致性。这种调度叫**可串行化**调度。

##### 并发一致性问题

常见并发并发一致性问题包括：丢失的修改、不可重复读、读脏数据、幻影读

1. 丢失修改：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。
2. 不可重复读（Non-Repeatable Read）：不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。
3. 读脏数据（dirty read）：读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
4. 幻影读（Phantom）：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。不可重复读重点在于update和delete，而幻读的重点在于insert。

##### 事务的隔离级别

- 未提交读（read uncommited）：允许读取未提交的数据。

  可能发生脏读、不可重复读和幻读问题

- 已提交读（read commmited）：只能读取到已经提交的数据，但不要求可重复读。

  解决了脏读的问题，但可能发生不可重复读和幻读问题

- 可重复读（repeatable read）：只允许读到已提交数据，并且在一个事务两次读取一个数据期间，其它事务不得更新该数据。

  解决了脏读和不可重复读的问题，但可能发生幻读问题。

- 可串行化（serializable）：保证可串行化调度。

  各种问题（脏读、不可重复读、幻读）都不会发生

##### 隔离性级别的实现

1. 锁

   有两种锁，共享锁和排它锁。共享锁用于事务读，排它锁用于事务写。许多事务可以共同持有一个数据的共享锁，但是只有在其他事务对于该数据项不持有任何锁时（无论排它锁还是共享锁），一个事务才允许持有该数据项的排它锁。

2. 时间戳

   数据库为每个事务分配一个时间戳，通常是事务开始的时候。对于每个数据项，系统分配两个时间戳，一个读时间戳一个写时间戳。读时间戳记录读该数据项的事务的最大时间戳，写时间戳记录写数据库当前值的写操作的时间戳。事务按照时间戳的顺序来访问数据项。如果当冲突发生时，事务终止，并会被分配一个新的时间戳。

3. 多版本和快照隔离

   通过维护数据项的多版本，一个事务允许读取一个旧版本的数据项。

   快照隔离是一种实现方法。在快照隔离中，每个事务开始时都有该版本的数据库。它从这个版本读取数据，并且修改当前版本的数据。当事务提交时，该版本会正式更新到真正的数据库中。

#### 锁

锁的种类：

- 共享锁（shared）：如果事务获得数据项 Q 的共享锁，那么事务可以读但是不能写 Q
- 排它锁（exclusive）：如果事务获得数据项 Q 的排它锁，那么事务既可读又可写 Q

##### 乐观锁 悲观锁

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。

悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

**实现方法**

乐观锁

1. CAS（Compare And Swap）：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。
2. 版本号：在数据中增加一个字段version，表示该数据的版本号，每当数据被修改，版本号加1。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。

CAS只能保证单个变量操作的原子性，而synchronized则可以通过对整个代码块加锁来处理。

当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。

##### 封锁协议

**一次封锁法**：在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。

**两阶段封锁协议**

协议要求事务分两个阶段提出加锁和解锁申请

- 增长阶段：事务可以获得锁，但不能释放锁
- 缩减阶段：事务可以释放锁，但不能获得新锁

这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化。

##### 锁管理器

锁管理器接受锁请求消息，返回锁授予消息。锁管理器为每个加锁的数据项维护一个链表，每一个请求为链表中的一条记录，按照请求的时间顺序排列。

![1611173485190](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1611173485190.png)

##### 死锁

死锁状态：如果存在一个事务集，集合的每个事务都在等待另一个事务。

如果一个系统四个条件同时满足，会发生死锁。发生死锁的必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

处理死锁的两种方法：

- 死锁预防：保证系统永不进入死锁状态
- 死锁检测：允许系统进入死锁状态，然后通过死锁检测和死锁恢复机制恢复系统

**死锁预防**

1. 每个事务在开始之前封锁所有需要的数据项（一段封锁）
2. 规定所有事务只能以按照规定的顺序封锁数据项

**死锁检测**

死锁可以通过等待图（wait for graph）进行判断。图的顶点代表事务，边 $T_i \rightarrow T_j$ 代表 $T_i$ 等待 $T_j$ 释放所需的数据项。当等待图中包括环时，系统中存在死锁。

**死锁恢复**

接触死锁的通常做法是回滚一个或者多个数据项。需要采取的动作为

1. 选择牺牲者

   需要选择回滚哪一项事务使得系统代价最小。影响系统代价的因素有：1）事务已经计算的时间。2）事务已经使用多少数据项。3）事务还需多少数据项。4）回滚时牵扯多少事务。

2. 回滚

   回滚某些事务时，需要决定事务回滚多远。

   - 彻底回滚：中止事务，并重新开始。
   - 部分回滚：事务只回滚到可以解除死锁状态。这种回滚需要额外信息，包括锁的申请/授予顺序，以及事务的更新。通过死锁检测机制，我们确定为了打破死锁，需要释放哪些锁。在部分回滚时，需要回滚到第一次获得这些锁之前。

3. 饿死（stravation）

   如果选择牺牲者基于代价因素，有可能同一事务总是被选为牺牲者。如此，该事物不能完成，成为饿死。解决方案是，在代价因素中包括回滚次数。

#### 索引

索引是储存一个表的特定列的值数据结构，通常由b树实现。如果一个表没有索引，在运行查找操作时，数据库需要一行一行查找每一行，进行全表扫描。使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。

**搜索码**是数据表中用于查找的属性或者属性集。复合搜索码指包含多个属性的搜索码。

索引的类型

- 顺序索引：基于值的顺序排列

  聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。

  - 聚集索引（clustering index）：索引中的数据物理存放地址和索引的顺序是一致的

    **优点：**数据访问更快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。

    **缺点：**对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，从而降低了执行速度。

  - 非聚集索引（nonclustering index）：索引中的数据物理存放地址和索引的顺序是不同的

    **优点**：更新索引的代价小

    **缺点**：非聚集索引中叶节点的data域存放的是数据记录的地址，相比较聚集索引中叶节点包含了完整的数据记录，数据访问速度较慢。

    聚集索引适用于查找某个范围内的数据，而非聚集索引适用于经常更新数据项的值

  - 稠密索引（dense index）：数据表中每一个搜索码值都有一个索引项

  - 稀疏索引 / 辅助索引（sparse index）：只为数据表中的某些搜索码值建立一个索引项。只有当索引是聚集索引时才能使用稀疏索引。为了定位一条数据项，需要找到一个最大搜索码值小于等于该条数据的搜索码值的索引，然后从该索引指向的记录开始，按照顺序查找。

    使用稠密索引比稀疏索引可以更快地定位到一条记录，但是稀疏索引所需要的空间更小，并且插入和删除索引项的开销也更小。

  - 多级索引：具有两级或者两级以上的索引。假设一层索引是稠密索引，可以在该层索引上构造一个稀疏的外层索引。

    如果当索引项比较多，不能放进内存时。搜索一个数据项需要多次从磁盘中读取索引数据块。虽然可以用二分法定位索引项，但搜索一个大的索引项仍是一个耗时的过程。使用多级索引可以减少需要的I/O 操作。

    ![1611107640881](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1611107640881.png)

- 散列索引：将值平均分布到若干散列桶中，一个值所属的桶是由一个函数决定的，这个函数成为散列函数

  - 静态散列：
  - 动态散列：允许散列函数动态改变,以适应数据库的增大或者缩小的变化需要

散列索引：散列函数将值分布到若干散列桶中。对于散列函数，我们期待它满足两个特性。

1. 分布是随机的。散列函数应为每个桶分配同样数量的搜索码值。
2. 分布是均匀的。散列值应该是随机的，不和搜索码值的任何外部特征相关。

可扩充散列：当数据库增大或者缩小时,可扩充散列可以通过桶的分裂或者合并来适应数据库大小的变化.这样可以保持空间的使用效率,此外,由于重组桶仅仅对一个桶或者少量桶进行操作,因此所带来的性能开销较低.

位图索引（bitmap）：对于每个索引项，生成一组位图向量。

比如对于性别这个列，位图索引形成两个向量，男向量为10100...，向量的每一位表示该行是否是男，如果是则位1，否为0，同理，女向量位01011。对于婚姻状况这一列，位图索引生成三个向量，已婚为11000...，未婚为00100...，离婚为00010...。通过对这两个向量进行位运算，可以快速获得查找项。

https://www.cnblogs.com/lbser/p/3322630.html

MySQL 中的几种索引类型

- PRIMARY 主键。 就是 唯一 且 不能为空。
- INDEX 索引，普通的
- UNIQUE 唯一索引，不允许有重复。

存储过程

存储过程用来实现复杂功能的SQL程序。存储过程就是具有名字的一段代码，用来完成一个特定的功能。

#### 存储引擎

存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。

MySQL中有几种常用的引擎：

**InnoDB 存储引擎**

InnoDB 使用 b+ tree。它的特点为：1) 支持事务，以及事务相关联功能。2）支持外键。3）支持自增长列。

InnoDB适合：1）可靠性要求比较高，或者要求事务；2）表更新和查询都相当的频繁，并且表锁定的机会比较大的情况。

**MyISAM存储引擎**

它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。

MyISAM适合：1）做很多count 的计算；2）插入不频繁，查询非常频繁；3）没有事务。

#### SQL 注入

当我们动态访问网页时，服务器会向数据库发送 SQL 请求。一般情况下这些请求是安全的。如果需要结合用户输入动态构造 SQL 语句，如果用户输入的数据构造成恶意 SQL 代码，称之为 SQL 注入。

SQL 注入的原理

1. 恶意拼接查询

   SQL 语句可以查询、插入、更新和删除数据，且使用分号来分隔不同的命令。

   ```SELECT * FROM users WHERE user_id = $user_id```

   但如果用户输入的 user_id 携带有其他语句

   ```SELECT * FROM users WHERE user_id = 1234; DELETE FROM users```

2. 利用注释执行非法命令

3. 传入非法参数

   SQL 语句中传入的字符串参数是用单引号引起来的，如果字符串本身包含单引号而没有被处理，那么可能会篡改原本 SQL 语句的作用。 

4. 添加额外条件

   在 SQL 语句中添加一些额外条件，以此来改变执行行为。条件一般为真值表达式。

   ``````
   UPDATE users SET userpass='$userpass' WHERE user_id=$user_id;
   UPDATE users SET userpass= '123456' WHERE user_id=1234 OR TRUE;
   ``````

避免 SQL 注入的方法

1. 过滤输入内容，校验字符串

   比如对于某个传入的值，如果可以确定是整型，则要判断它是否为整型

2. 参数化查询

   收到一条 SQL 发生的事情：收到指令 -> 编译SQL生成执行计划 ->选择执行计划 ->执行执行计划。拼接SQL 被注入的原因是没有重用以前的执行计划，因为对注入后的SQL语句重新进行了编译。

   参数化查询指指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数来给值。

   ```
   String sql = "select * from user where username=? and passwd=?";
   ps = conn.PreparedStatement(sql);
   ps.setString(1, "admin");
   ps.setString(2, "123456");
   ```

   

   参数化的 SQL 经过了预编译，此时 SQL 语句的执行计划已经生成。即便对 passwd 传一个 ```OR TRUE``` 的参数，```OR TRUE``` 会当做参数（passwd）的值，而不会改变 SQL 的执行计划。

