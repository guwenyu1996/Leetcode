#### Java 执行过程

![img](https://img2018.cnblogs.com/blog/595137/201812/595137-20181212194650912-14632118.png)

#### Jvm 内存模型

![1612147996598](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612147996598.png)

Java 虚拟机的内存结构可以分为公有和私有两部分。公有指的是所有线程都共享的部分，指的是 Java 堆、方法区、常量池。私有指的是每个线程的私有数据，包括：PC寄存器、Java 虚拟机栈、本地方法栈。

公有部分：

- Java 堆：存放对象实例。Java 堆也是垃圾收集器管理的主要区域，也称 GC 堆（garbage collected heap）。Java 堆根据对象存活时间的不同，Java 堆还被分为年轻代、老年代两个区域，年轻代还被进一步划分为 Eden 区、From Survivor 0、To Survivor 1 区。

  ![img](https://img2018.cnblogs.com/blog/595137/201901/595137-20190103103329413-247778313.png)

  当有对象需要分配时，一个对象永远优先被分配在年轻代的 Eden 区，等到 Eden 区域内存不够时，Java 虚拟机会启动垃圾回收。此时 Eden 区中没有被引用的对象的内存就会被回收，而一些存活时间较长的对象则会进入到老年代。

- 方法区：存储 Java 类字节码数据的一块区域，它存储了每一个类的结构信息、常量、静态变量

- 运行时常量池：方法区的一部分，有两种类型，符号引用（symbolic references）和静态常量（static constants）。String类型就是静态常量之一

私有部分：

- 程序计数器：存放下一条指令所在单元的地址。因为 Java 虚拟机的多线程是通过线程轮流切换并分配 CPU 的方式实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。
- Java 虚拟机栈：这个栈与线程同时创建，存储当前线程运行方法所需的数据，包括局部变量表、操作数栈。
- 本地方法栈（native method stack）：虚拟机调用native 方法（非 Java）时创建的栈。

#### 对象的创建过程

1. 虚拟机检查这个类是否已经被加载过，如果没有，执行类加载过程

2. 在 Java 堆上为对象分配内存

   如果堆上内存分配是规整的，一边是用过的内存，一边没用过。那么分配内存相当于把中间指针往没用过那边挪动；如果分配是不规整的，那么虚拟机需要维护一个列表，记录那些内存可用，哪些不可用。

   分配内存也需要保证进程安全。方法1）对分配内存空间的动作进行同步控制，使用CAS；方法2）给每个线程在Java 堆中分配一小块内存，哪个线程需要分配内存，对哪块进程同步锁定。

3. 设置对象头

   设置对象是哪个类实例、元数据、哈希码、对象的 GC 信息

4. 对对象赋值

   此时全部字段还为0，执行new方法，把对象的值初始化。

#### 对象的内存分布

对象在内存中分为3个区域：对象头、实例数据和对齐填充。

对象头包括两部分数据：

- 对象自身运行时数据：哈希码、GC分带年龄、锁状态标志、线程持有的锁、时间戳
- 指向类元数据的指针：虚拟机通过这个指针判断对象是哪个类的实例

#### 垃圾回收

垃圾回收主要包括三个问题：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

##### 判断对象是否已死？

##### 引用计数算法

给对象添加一个引用计数器，每当有一个地方引用它时，计数器值+1；当引用失效时，计数器值-1。引用计数为 0 的对象可被回收。

缺点是很难解决对象之间相互循环引用的问题。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

##### 可达性分析

主流的程序语言都是通过可达性分析（reachability analysis）判断对象是否存活的。以 GC Roots 为起始点进行搜索，从节点开始向下进行搜索，可达的对象都是存活的，不可达的对象可被回收。

Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：

- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中 JNI 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

##### 引用类型

1. 强引用（strong reference）

   java中的引用默认就是强引用，任何一个对象的赋值操作就产生了对这个对象的强引用。

   ``` Object obj = new Object();```

   上面我们new了一个Object对象，并将其赋值给obj，这个obj就是new Object()的强引用。

   强引用的特性是只要有强引用存在，被引用的对象就不会被垃圾回收。

2. 软引用（soft reference）

   软引用在java中有个专门的SoftReference类型，软引用的意思是只有在内存不足的情况下，被引用的对象才会被回收。

   ``` Object obj = new Object(); SoftReference<Object> soft = new SoftReference<>(obj);```

3. 弱引用（weak reference）

   weekReference引用的对象只要垃圾回收执行，就会被回收，而不管是否内存不足。

   ```WeakReference<Object> weak = new WeakReference<>(obj);```

4. 虚引用（phantom reference）

   PhantomReference的作用是跟踪垃圾回收器收集对象的活动，在GC的过程中，如果发现有PhantomReference，GC则会将引用放到ReferenceQueue中，由程序员自己处理，当程序员调用ReferenceQueue.pull()方法，将引用出ReferenceQueue移除之后，Reference对象会变成Inactive状态，意味着被引用的对象可以被回收了。

##### 方法区的垃圾回收

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

主要回收两部分：废弃常量和无用的类。

判断一个类是无用的类需要满足三个条件，并且满足了条件也不一定会被卸载：

- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

#### 垃圾回收算法

##### 标记清除算法

算法分成两个阶段：标记阶段和清除阶段。首先先标记出所有需要回收的对象（使用可达性分析）之后在清除阶段，清除所有未被标记的对象。

不足：

- 标记和清除过程效率都不高；

- （不会挪动已经被分配空间的对象）会产生大量不连续的内存碎片，导致无法给大对象分配内存。

  ![1612081666267](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612081666267.png)

##### 复制算法

算法将可用内存分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另一块上面，之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色。

优点：分配内存时不需要考虑内存碎片的情况，只需要顺序分配内存即可

缺点：1) 需要比较多复制操作 2) 内存缩小一半

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。

![1612082066811](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612082066811.png)

##### 标记整理算法

标记过程和标记清除算法一样，但是在后续阶段 让所有存活的对象向一边移动，然后清理端边界以外的内存。

![1612082639455](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612082639455.png)

##### 分代收集算法

当前商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，一般是把Java 堆分为新生代和老年代，不同块采用适当的收集算法。

- 新生代：每次垃圾收集都有大批对象死去，少量存活，选用复制算法，只需要复制少量存活对象就可以完成收集
- 老年代：对象存活利率高，使用标记-清理或者标记-整理

#### 垃圾回收器

垃圾收集器是内存回收的具体实现。

![1612084197452](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612084197452.png)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程（并发）：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行（在同一时间点）。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。
- **并行（Parallel）**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。

##### Serial 收集器

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。在新生代串行回收器中使用的是复制算法。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

![1612084828077](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612084828077.png)

##### Serial old 收集器

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

##### ParNew 收集器

它是 Serial 收集器的多线程版本。

它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

![1612085052237](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612085052237.png)

##### Parallel scanvenge 收集器

与 ParNew 一样是多线程收集器。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU =运行用户代码时间/（用户代码时间+垃圾收集时间）。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

##### Parallel old 收集器

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

##### CMS 收集器

CMS (concurrent mark sweep) 收集器是以获取最短回收停顿时间为目标的收集器。适用于b/s系统的服务端，这类应用中是服务的响应速度，希望系统停顿时间最短，给用户带来较好的体验。

分为以下四个流程：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：从GC Root进行可达性分析，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。

![1612087256533](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612087256533.png)

优点：并发收集、低停顿

缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于垃圾收集结点用户进程还需要运行，那么还需要预留足够的内存空间给用户线程使用，所以CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够无法满足程序需要，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 Serial Old有长时间停顿。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

##### G1收集器

G1 (garbage first) 收集器是当前最前沿的收集器之一。

具有以下特点：

- **并行与并发**：G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
- **分代收集**：采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象
- **空间整合**：基于**“标记-整理”**算法实现的收集器，这意味着G1运行期间不会产生内存空间碎片
- **可预测的停顿**：这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，

其他收集器是作用于整个新生代或者老年代，而G1 收集器将整个Java堆划分为多个大小相等的独立区域（region），新生代和老年代是一部分不需要连续的region的集合。

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

**建立可预测的时间模型**

G1收集器之所以能建立可预测的停顿时间模型，是因为它可以**有计划地避免在整个Java堆中进行全区域的垃圾收集**。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），**在后台维护一个优先列表**，每次根据允许的收集时间，**优先回收价值最大的Region（这也就是Garbage-First名称的来由）**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

**避免全堆扫描——Remembered Set**

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![1612089377450](C:/Users/wenyu/AppData/Roaming/Typora/typora-user-images/1612089377450.png)

G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记：标记GC Root能直接关联的对象
- 并发标记：从GC Root进行可达性分析
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

#### 内存分配与回收策略

Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。

Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

##### 内存分配策略

1. 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

3. 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

4. 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

5. 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

##### Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

1. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

2. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

3. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。

4. JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

#### 类加载机制

##### 类加载过程

虚拟机将class文件加载到内存，对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

包括以下 7 个阶段：

- **加载（Loading）**
- **验证（Verification）**
- **准备（Preparation）**
- **解析（Resolution）**
- **初始化（Initialization）**
- 使用（Using）
- 卸载（Unloading）

###### 加载

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

非数组类的加载阶段（准确说是加载阶段中获取类二进制字节流）可以由系统提供的引导类加载器完成，也可以由用户自定义的类加载器完成（重写loadClass方法）。

###### 验证

验证的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段完成4个阶段的验证：

1. 文件格式验证：验证字节流是否符合 class文件格式，并且能被虚拟机处理

   可能的错误：1）是否以魔数开头

2. 元数据验证：对类的元数据进行校验

   可能的错误：1）父类是否继承了不允许被继承的类 2）类中字段是否与父类冲突

3. 字节码验证：验证程序语义是合法的

   可能的错误：1）指令跳转到方法体以外的字节码上

4. 符号引用验证：

###### 准备

准备阶段的主要任务是 为类变量分配内存 以及 设置类变量初始值。这些变量所使用的内存都将在**方法区**中分配。

在准备阶段进行内存分配的仅包括**类变量（被static修饰的变量）**，而不包括**实例变量**。

其次，这里所说的初始值“通常情况”下是数据类型的零值，而不是用户代码里初始化的值。特殊情况是如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。

###### 解析

解析阶段是虚拟机将**常量池**内的**符号引用**替换为**直接引用**的过程。

- **符号引用（Symbol References）**： 符号引用**以一组符号来描述所引用的目标**，**符号**可以是**任何形式的字面量**，只要使用时能无歧义地定位到目标即可。**符号引用与虚拟机实现的内存布局无关**，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致，因为**符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中**。
- **直接引用（Direct References）**： 直接引用可以是**直接目标的指针**、**相对偏移量**或是一个**能间接定位到目标的句柄**。直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中存在。

###### 初始化

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit\>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

<clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。

##### 类与类加载器

虚拟机设计团队把类加载阶段中的**“通过一个类的全限定名来获取描述此类的二进制字节流(即字节码)”**这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为**“类加载器”**。

一般来说，Java 虚拟机使用 Java 类的方式如下：

1. **Java 源程序（.java 文件）**在经过 Java 编译器**编译**之后就被转换成**字节码（.class 文件）**。
2. 类加载器负责读取 Java 字节代码，并转换成 `java.lang.Class`类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 `newInstance()`方法就可以创建出该类的一个对象。

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。

这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

##### 类加载器分类

从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：

- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。

从 Java 开发人员的角度看，类加载器可以划分得更细致一些：

- 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。
- 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

##### 双亲委派模型

![img](https://pic.yupoo.com/crowhawk/188f5d64/26536d6a.png)

模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。

工作过程：一个类加载器首先将类加载请求转发到父类加载器，加载请求最终会传送到顶层的启动类加载器中，只有当父类加载器无法完成时才尝试自己加载。

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

好处：例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。

#### Java 内存模型

Java 虚拟机定义一种 Java 内存模型（Java memory model, JMM）来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能打到一致的内存访问效果。

Java 内存模型规定所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存被线程使用的变量的主内存副本拷贝，线程对变量的操作在工作内存中进行。

类比jvm内存模型，主内存对应 Java 堆中的对象实例，工作内存对应虚拟机栈中的部分区域；类比物理模型，主内存对应于武力营救的内存，为了获得更好的运行速度，工作内存优先存储在寄存器和高速缓存中。

关于主内存和工作内存之间的交互，java 虚拟机定义了8种操作。每种操作都是原子性、不可再分的。

##### volatile

volatile修饰之后，那么就具备了两层语义：

1. 保证了不同线程对变量操作的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

   当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存

   当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。

2. 禁止进行指令重排序。

并发编程中的三个概念:

1. 原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

2. 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

3. 有序性：程序执行的顺序按照代码的先后顺序执行。

   指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。